#include "FanmetaGenerator.h"

#include <stdlib.h>

#include <cstdint>
#include <iostream>
#include <memory>
#include <regex>
#include <vector>

#include <google/protobuf/stubs/strutil.h>

#include <google/protobuf/stubs/logging.h>
#include <google/protobuf/stubs/common.h>
#include <google/protobuf/compiler/plugin.pb.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/io/zero_copy_stream.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/text_format.h>
#include <google/protobuf/stubs/substitute.h>
#include "FanmetaMessage.h"
#include "FanmetaEnum.h"

#ifdef major
#undef major
#endif
#ifdef minor
#undef minor
#endif

namespace google {
	namespace protobuf {
		namespace compiler {

			// Returns the list of the names of files in all_files in the form of a
			// comma-separated string.
			std::string CommaSeparatedList(
				const std::vector<const FileDescriptor*>& all_files) {
				std::vector<std::string> names;
				for (size_t i = 0; i < all_files.size(); i++) {
					names.push_back(all_files[i]->name());
				}
				return Join(names, ",");
			}

			FanmetaGenerator::FanmetaGenerator() {}

			FanmetaGenerator::~FanmetaGenerator() {}

			uint64_t FanmetaGenerator::GetSupportedFeatures() const {
				uint64_t all_features = CodeGenerator::FEATURE_PROTO3_OPTIONAL;
				return all_features & ~suppressed_features_;
			}

			void FanmetaGenerator::SuppressFeatures(uint64_t features) {
				suppressed_features_ = features;
			}

			bool FanmetaGenerator::Generate(const FileDescriptor* file, const std::string& parameter, GeneratorContext* context, std::string* error) const {

				// Enum
				{
					std::unique_ptr<io::ZeroCopyOutputStream> output(context->Open(file->name() + ".enum.pb.cs"));
					io::Printer printer(output.get(), '$', nullptr);

					for (int i = 0; i < file->enum_type_count(); i++)
					{
						const EnumDescriptor* enum_desc = file->enum_type(i);
						FanmetaEnum enum_gen(enum_desc);
						enum_gen.Write(printer);
					}

					if (printer.failed()) {
						*error = "FanmetaEnum detected write error.";
						return false;
					}
				}
				// Message
				{
					std::unique_ptr<io::ZeroCopyOutputStream> output(context->Open(GetOutputFileName(file)));
					io::Printer printer(output.get(), '$', nullptr);

					for (int i = 0; i < file->message_type_count(); i++)
					{
						const Descriptor* message_desc = file->message_type(i);
						FanmetaMessage message(message_desc, file->package());
						message.Write(printer);
					}

					if (printer.failed()) {
						*error = "FanmetaMessage detected write error.";
						return false;
					}
				}

				// Rpc
				{
					std::unique_ptr<io::ZeroCopyOutputStream> output(context->Open("RpcController.cs"));
					io::Printer printer(output.get(), '$', nullptr);
					std::map<std::string, std::string> vars;

					auto ConvertToEnumName = [&](const std::string& typeName)->std::string {
						std::string ret = "";
						std::regex rgx("[A-Z]");
						std::sregex_token_iterator iter(typeName.begin(), typeName.end(), rgx);
						std::sregex_token_iterator second_iter(typeName.begin(), typeName.end(), rgx, -1);
						std::sregex_token_iterator end;

						for (; second_iter != end; ++second_iter)
						{
							auto second = *second_iter;
							if (second.length() <= 0)
							{
								continue;
							}

							auto first = *iter;
							ret = ret + first.str() + second.str();
							++iter;

							if (iter != end)
							{
								ret += '_';
							}
						}

						for (auto& value : ret)
						{
							value = toupper(value);
						}

						return "EMessageType.MT_" + ret;
					};

					for (int i = 0; i < file->service_count(); ++i)
					{
						auto service = file->service(i);

						printer.Print("// This file is automatically generated, please do not modify it!!\n");
						printer.Print("using AppClient.Pattern;\nnamespace AppClient.Network\n{\n\t[CSLStub.Out(\"Network\")]\n\tpublic class RpcController : TKController {\n");
						printer.Print("\t\tprivate readonly NetworkController _networkController = ControllerManager.GetController<NetworkController>();\n");
						printer.Print("\t\tprivate readonly MessageController _messageCallback = ControllerManager.GetController<MessageController>();\n");

						printer.Print("\t\tpublic RpcController() {\n");
						for (int i = 0; i < file->message_type_count(); i++)
						{
							const Descriptor* message_desc = file->message_type(i);
							auto message_name = message_desc->name();

							// 推送
							if (message_name.find("Event") != std::string::npos)
							{
								auto enumName = ConvertToEnumName(message_name);
								vars.clear();
								vars.insert(std::make_pair("message_code", enumName));
								vars.insert(std::make_pair("message_name", message_name));
								printer.Print(vars, "\t\t\t_messageCallback.MessageCallback.RegisterCommand($message_code$, $message_code$, $message_name$.FullName);\n");
							}
							// 请求响应
							else if (message_name.find("Response") != std::string::npos)
							{
								vars.clear();
								auto tmpMessageName = message_name;
								auto reqCode = ConvertToEnumName(tmpMessageName.replace(tmpMessageName.find("Response"), strlen("Response"), "Request"));
								auto respCode = ConvertToEnumName(message_name);
								vars.insert(std::make_pair("req_code", reqCode));
								vars.insert(std::make_pair("resp_code", respCode));
								vars.insert(std::make_pair("message_name", message_name));
								printer.Print(vars, "\t\t\t_messageCallback.MessageCallback.RegisterCommand($req_code$, $resp_code$, $message_name$.FullName);\n");
							}
						}
						printer.Print("\t\t}\n");

						for (int j = 0; j < service->method_count(); ++j)
						{
							auto method = service->method(j);
							vars.clear();
							vars.insert(std::make_pair("method_name", method->name()));
							vars.insert(std::make_pair("input_type", ConvertToEnumName(method->input_type()->name())));
							vars.insert(std::make_pair("output_type", method->output_type()->name()));
							printer.Print(vars, "\t\tpublic Promise $method_name$(byte[] bytes, System.Action<Packet> onSuccess) {\n\t\t\treturn Promise.Create((resolved, rejected) => \n\t\t\t{\t\t\t\n\t\t\t\t");
							printer.Print(vars, "_networkController.Call(bytes, $input_type$, (o)=>{var header = o.Header; if (header.error_code != EErrorCode.SUCCESS) { LuaDebug.error(\"Rpc Error - $method_name$ - \" + header.error_code); rejected(header.error_code); return; } onSuccess?.Invoke(o); resolved(o);}, rejected);");
							printer.Print("\n\t\t\t});\n\t\t}\n");

							// 仅仅发送，不做监听
							printer.Print(vars, "\t\tpublic Promise $method_name$CallOnly(byte[] bytes) {\n\t\t\treturn Promise.Create((resolved, rejected) => \n\t\t\t{\t\t\t\n\t\t\t\t");
							printer.Print(vars, "_networkController.CallOnly(bytes, $input_type$); resolved(null);");
							printer.Print("\n\t\t\t});\n\t\t}\n");
						}
						printer.Print("\t}\n}");
					}
				}
				return true;
			}

			std::string FanmetaGenerator::GetOutputFileName(const FileDescriptor* file) {
				return GetOutputFileName(file->name());
			}

			std::string FanmetaGenerator::GetOutputFileName(const std::string& file) {
				return file + ".pb.cs";
			}
		}  // namespace compiler
	}  // namespace protobuf
}  // namespace google

